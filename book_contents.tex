\author{Nicky D. van  Foreest}

\begin{document}
\frontmatter
\maketitle

\tableofcontents

\chapter{Introduction}
\label{cha:introduction}
%\addcontentsline{toc}{chapter}{Introduction}

\input{tex_files/intro.tex}
\clearpage

\input{tex_files/preliminaries.tex}

\mainmatter

\chapter{Construction and Simulation of Queueing Systems}
\label{cha:single-stat-queu}


The first step to analyze a queueing system is to model it.
And for this, there is often not a better start then to build a simulation model.
Thus, the aim of this chapter is to teach you how to construct and simulate queueing processes.

In~\cref{sec:constr-discr-time} we build discrete-time models of queueing systems, which means that we use the number of jobs that arrive and can be served in a periods to construct the queueing process.
Such a period can be an hour, or a day; in fact, any amount of time that makes sense in the context in which the model will be used.
Typically we model the number of arrivals and potential services as random variables, and in many practical settings it is reasonable to take the number of arrivals in a period as Poisson distributed.
This being the case, we consider the Poisson distribution in~\cref{sec:poisson-distribution}, and once we have an understanding of this, we can use random number generators to generate (Poisson distributed) random numbers of arrivals and services to drive the simulator.


In~\cref{sec:constr-gg1-queu} we focus on constructing queueing processes in continuous time.
In this setting, the inter-arrival times and service times of individual jobs become of importance, and then exponentially distributed random variables play a fundamental role.
We therefore discuss the properties of the exponential distribution in~\cref{sec:expon-distr}.
We also mention the interestingly and close relationship between the exponential distribution and the Poisson distribution.

As will become apparent, both types of constructing queueing processes, the discrete-time or continuous-time models, are easy to implement as computer programs.
We include a large number of exercises to show you the astonishing diversity of queueing systems can be analyzed by simulation.
In passing, we develop a number of performance measures to provide insight into the (transient and long-run average) behavior of queueing processes.

We expect you to \emph{know all topics} summarized in~\cref{sec:preliminaries}; we use these extensively in~\cref{sec:poisson-distribution} and \cref{sec:expon-distr}, as well as in any other section that introduces some theory.

\input{tex_files/poissondistribution.tex}
\input{tex_files/constructiondiscretetime.tex}
\input{tex_files/expdistribution.tex}
\input{tex_files/constructioncontinuoustime.tex}

\chapter{From Transient to Steady-state Analysis}
\label{cha:from-trans-steady}


With the tools developed in~\cref{cha:single-stat-queu}  we can simulate queueing processes, but we cannot easily use mathematical models to analyze queueing systems.
The aim of this chapter is to make start with this latter subject. 
However, as we will see in~\cref{sec:queu-proc-as}, the mathematical analysis of the time-dependent behavior of queueing systems is beyond our capabilities; the transient behavior of even the simplest queueing system is already extremely  complicated. Thus, we have to lower our goals, and for this reason we will focus the steady-state behavior of queueing systems.
Intuitively speaking, this requires the system to be stable, for otherwise the queue length process grows to infinity.

We introduce concepts of stability and load in~\cref{sec:rate-stability} and express these in terms of the arrival, service and departure rates.
The notions of arrival and service rate are crucial because they capture our intuition that when jobs arrive faster on average than they can leave, the queue must `explode'.
As we will see, when the arrival rate is smaller than the service rate, the system is stable.
Once stability is ensured, we can properly define in~\cref{sec:limits-of-emperical} a number of measures to characterize the performance of the queueing system, such as the average waiting time.
%In the remainder of the book we use arrival rate, and so on, in every queueing model

Before introducing these definitions, however, we need to introduce some notational shorthands to characterize the type of queueing process. This is the topic of~\cref{sec:graphical-summaries_1}.
To help you, we provide in~\cref{sec:graphical-summaries_1} an overview of the relations we introduce in this chapter. 


\input{tex_files/kendall.tex}
\input{tex_files/random_walk.tex}
\input{tex_files/ratestability.tex}
\input{tex_files/empiricalperfmeasures.tex}
\input{tex_files/figure_summaries_1.tex}



\chapter{Approximate Queueing Models}
\label{cha:approximate-models}

TODO

In the first section of this chapter we present and apply Sakasegawa's formula to approximate the expected waiting time in queue at an $G/G/c$ queue, and in the last section we provide a formula to show how variability propagates in networks.
We might say that these two formulas are the most important formulas to understand the behavior of queueing systems.
With a bit of exaggeration, it is justified to say that the entire philosophy behind lean manufacturing and the world-famous Toyota production system are based on the principles that can be derived from these two formulas. These principles come down to: focus on the reduction of load and processing time variability, and realize that the size of production batches has a major effect on waiting times.

The idea behind this chapter is to familiarize the reader with a set of typical queueing (business) problems that can be addressed with these approximations.
In other words, here we take these formulas for granted, but focus on the insights they provide and how to use them to guide improvement procedures for queueing problems that are, in some way or another, often encountered in production and service systems.
In later sections, most notably~\cref{sec:mg1}, we will provide the background of Sakasegawa's formula and show that it is an exact result for the $M/G/1$ queue,

In~\cref{sec:gg1} we introduce and discuss the main insights of Sakasegawa's formula.
In the subsequent sections we illustrate how to use this formula to estimate waiting time in three examples in which the service process is interrupted.
In the first case the server has to produce jobs from different families, and there is a change-over time required to switch from one production family to another.
As such setups reduce the time the server is available to serve jobs, the load must increase.
In fact, to reduce the load, the server produces in batches of fixed sizes.
In the second case, the server sometimes requires small adjustments, for instance, to prevent the production quality to degrade below a certain level.
Clearly, such adjustments are typically not required during a job's service; however, they can occur at arbitrary moments in time.
Thus, this is different from batch production in which the batch sizes are constant.
In the third example, quality problems or break downs can occur during a job's service.
For each case we develop a model to analyze the influence of the interruptions on average job sojourn times.

In passing we use some interesting results of probability theory and the Poisson process. 

\input{tex_files/gg1.tex}
\input{tex_files/setup_times.tex}
\input{tex_files/adjustments.tex}
\input{tex_files/failures.tex}
\input{tex_files/tandem.tex}

\chapter{Fundamental tools}
\label{cha:fundamental-tools}

TODO

For the mathematical analysis of queueing systems we need a few concepts that are fundamentally important and have a general interest beyond queueing.
We start with developing sample-path constructions of queueing systems.
We then define several performance measures that can be estimated from characteristics of the sample paths, possibly obtained by simulation.

 and level-crossing arguments.



\input{tex_files/renewal_reward.tex}
\input{tex_files/levelcrossing.tex}
\input{tex_files/pasta.tex}
\input{tex_files/little.tex}
\input{tex_files/figure_summaries_2.tex}

\chapter{Exact Queueing Models}
\label{cha:analytical-models}

In this chapter we focus on developing analytic models for various queueing systems in steady-state.
As a reminder, we keep the discussion in these notes mostly at an intuitive level, and refer to \cite{el-taha98:_sampl_path_analy_queuein_system} for proofs and further background.

\input{tex_files/mm1.tex}
\input{tex_files/mnmn1.tex}
\input{tex_files/mxm1_pk.tex}
\input{tex_files/mg1.tex}
\input{tex_files/batcharrivals.tex}
\input{tex_files/mg1distributionqueuelength.tex}
% \input{tex_files/relationmxm1andmg1.tex}
%\input{tex_files/mg1density.tex}


\chapter{Queueing Control and Open Networks}
\label{cha:queu-contr-open}

TODO

In the queueing systems we analyzed up to now, the server is always present to serve jobs in the system. However, this condition is not always satisfied.
As an example, consider a queueing system in which there is a cost associated with switching on and off the server.
For instance, in some cases the server has to be set-up for operation; in other cases, the operator of a machine has to move from one place in the factory to another.
To reduce the cost, a so-called $N$-policy can be used, which works as follows, cf.~\cref{ex:n-policies}.
As soon as the system becomes empty (and the server idle), we switch off the server.
Then we wait until $N$ or more jobs arrived and then switch on the server.
The server processes jobs until the system is empty again, and then switches off again, and so on.
Thus, we use an $N$-policy to \emph{control} the queueing system, in particular the server, and the task is to find a switching threshold~$N$ that minimizes the long-run average cost.

Observe that under such policies the server occupancy can also increase.
In fact, this sometimes seems to the policy at dentists or hospitals: wait until the waiting room is quite full, and then start serving patients.
Like this the server minimizes idle time, and, in the example of a GP, the server (GP) does not have to wait for patients that might be late.

In this chapter we study the $M/M/1$ queue and $M/G/1$ under a $N$-policy, and then consider a $T$-policy.
We next focus on a policy that controls the server rate as a function of waiting time in the system.


We point out that the techniques developed in this chapter extend (way) beyond just queueing theory; they are worth memorizing.
Moreover, we illustrate many tools and results of the previous chapters.
Moreover, the concepts we introduce here can be generalized to (optimal) stopping problems, which find many applications beyond queueing, such in finance, inventory theory, decision theory, and so on.


\input{tex_files/n_policies_mm1.tex}
\input{tex_files/n_policies_mg1.tex}
\input{tex_files/open_single_class.tex}
\input{tex_files/gershgorin.tex}



%\input{tex_files/deterministic_networks.tex}
%\input{tex_files/gordon_newell.tex}
%\input{tex_files/convolution.tex}
%\input{tex_files/mva.tex}
%\input{tex_files/mda.tex}


\backmatter

\addcontentsline{toc}{chapter}{Bibliography}
\phantomsection
\bibliographystyle{plainnat}
\bibliography{biblio_nicky}


\chapter{Notation}
\label{sec:notation}
%\addcontentsline{toc}{chapter}{Notation}
\input{tex_files/notation.tex}

\chapter{Formula Sheet}
%\addcontentsline{toc}{chapter}{Formula Sheet}
\input{tex_files/formula_sheet.tex}

\addcontentsline{toc}{chapter}{Index}
\phantomsection
\printindex

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "companion"
%%% End:
